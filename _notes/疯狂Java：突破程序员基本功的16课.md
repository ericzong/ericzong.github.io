---
layout: page
title: 疯狂Java：突破程序员基本功的16课
category: Java
author: "Eric Zong"
---

* content
{:toc}

# 数组与内存控制

## 数组初始化方式

* 静态初始化：初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。
* 动态初始化：初始化时程序员只指定数组长度，由系统为数组元素分配初始值。

动态初始化时，系统会为数组元素自动分配初始值，其规则只有一条：将数据空间的二进制位全部用 0 填充。

初始化是针对引用对象而言的，引用变量本身是不需要初始化的。

引用变量本质上只是一个指针，只要程序通过引用变量访问属性，或者通过调用引用变量来调用方法，该引用变量将会由它所引用的对象代替。

引用类型数组的数组元素依然是引用类型的，因此数组元素里存储的还是引用。

Java 语言不允许直接访问堆内存中的数据，因此无法直接访问堆内存中的数组对象，程序将通过数组引用变量来访问数组。

# 对象与内存控制

Java程序的变量分为：成员变量和局部变量。

## 局部变量种类

* 形参：在方法签名中定义的局部变量，由方法调用者负责为其赋值，随方法的结束而消亡。

* 方法内的局部变量：在方法内定义的局部变量，必须在方法内对其进行显式初始化。从初始化完成后开始生效，随方法的结束而消亡。

* 代码块内的局部变量：在代码块内定义的局部变量，必须在代码块内对其进行显式初始化。从初始化完成后开始生效，随代码块的结束而消亡。

static 只能修饰在类里定义的成员部分，包括成员变量、方法、内部类、初始化块、内部枚举类；不能修饰外部类、局部变量、局部内部类。

 由于同一个JVM 内每个类只对应一个Class 对象，因此同一个JVM 内的一个类的类变量只需一块内存空间。

## 实例变量的初始化时机

* 定义实例变量时指定初始值
* 非静态初始化块中对实例变量指定初始值
* 构造器中对实例变量指定初始值

## 类变量的初始化时机

* 定义类变量时指定初始值

* 静态初始化块中对类变量指定初始值


 super 调用和this 调用都只能在构造器中使用，而且super 调用和this调用都必须作为构造器的第一行代码， 因此构造器中的super调用和this 调用最多只能使用其中之一，而且最多只能调用一次。

 当this在构造器中时， this 代表正在初始化的Java对象。

 如果父类构造器调用了被子类重写的方法，且通过子类构造器来创建子类对象，调用 (不管是显式还是隐式)了这个父类构造器，就会导致子类的重写方法在子类构造器的所有代码之前被执行， 从而导致子类的重写方法访问不到子类的实例变量值的情形。

Java程序允许某个方法通过turn this;返回调用该方法的Java对象，但不允许直接return super; ，甚至不允许直接将super 当成一个引用变量使用。

 由于Java 允许通过对象来访问类变量，因此也可以使用super. 作为限定来访问父类中定义的类变量。

 

## final修饰符使用范围

* 变量，赋初值后不能重新赋值

* 方法，不能被重写

* 类，不能派生子类


## final实例变量初始化时机

* 定义final实例变量时指定初始值

* 在非静态初始化块中指定初始值

* 在构造器中指定初始值


注：3种方式都会被抽取到构造器中赋初值。

 本质上final实例变量只能在构造器中被赋初始值。

## final类变量初始化时机

* 定义final类变量时指定初始值

* 在静态初始化块中指定初始值


注：2种方式都会被抽取到静态初始化中赋初始值。

 本质上final类变量只能在静态初始化块中被赋初始值。

 对于一个final 变量，不管它是类变量、实例变量，还是局部变量，只要定义该变量时使用了final修饰符修饰，并在定义该final 类变量时指定了初始值，而且该初始值可以在编译时就被确定下来，那么这个final 变量本质上已经不再是变量，而是相当于一个直接量。

如果被赋的表达式只是基本的算术运算表达式或字符串连接运算，没有访问普通变量，调用方法，Java 编译器同样会将这种final 变量当成"宏变量"处理。

 对于final 实例变量而言，只有在定义该变量时指定初始值才会有"宏变量"的效果， 在非静态初始化块、构造器中为final实例变量指定初始值则不会有这种效果。

 对于final 类变量而言，只有在定义final 类变量时执指定初始值，系统才会对该final类变量执行"宏替换"。

 如果父类中某个方法使用了final 修饰符进行修饰， 那么这个方法将不可能被它的子类访问到(?)，因此这个方法也不可能被它的子类重写。从这个意义上来说， private和final 同时修饰某个方法没有太大意义，但是被Java 语法允许的。

 如果程序需要在匿名内部类中使用局部变量，那么这个局部变量必须使用final 修饰符修饰。

 不仅匿名内部类，即使是普通内部类，在任何内部类中访问的局部变量都应该使用final 修饰。此处所说的内部类指的是局部内部类，因为只有局部内部矣(包括匿名内部类)才可以访问局部变量，普通静态内部类、非静态内部类不可能访问方法体内的局部变量。

 对于普通局部变量而言，它的作用域就是停留在该方法内，当方法执行结束，该局部变量也随之消失，但内部类则可能产生隐式的"闭包(Closure)" ，闭包将使得局部变量脱离它所在的方法继续存在。

由于内部类可能扩大局部变量的作用域，如果再加上这个被内部类访问的局部变量没有使用final 修饰，也就是说该变量的值可以随意改变，那将引起极大的混乱，因此Java 编译器要求所有被内部类访问的局部变量必须使用final 修饰符修饰。

 循环体中只包含一条局部变量定义语句时，循环体花括号不能省略，否则编译错误。

 instanceof 运算符前操作数限制：与后面类相同、是后面类的父（子）类，即在后面类的继承体系上。

 编译阶段，强转要求被转型变量的编译时类型在目标类型的继承体系上。

 非静态内部类系统在编译阶段会为构造器增加一个外部类参数作为第一参数。

 static 可修饰：Field、方法、内部类、初始化块、内部枚举类。

 