---
layout: page
title: Java解惑
category: Java
author: "Eric Zong"
---

* content
{:toc}

# 1.        表达式谜题

## 1.1    谜题1：奇数性

i%2 == 1 不能用于判断一个整数是否是奇数，有四分之一的概率得到错误答案，因为对于负奇数都返回false（i%2为-1）。

% 操作符被定义为对于所有的 int 数值 a 和所有的非零 int 数值 b，都满足恒等式：(a / b) * b + (a % b) == a。它具有正确的含义，但是当与 Java 的截尾整数整除操作符相结合时，它就意味着：当取余操作返回一个非零的结果时，它与左操作数具有相同的正负符号。

正确的写法是：i%2 != 0。在性能临界（performance-critical）环境中因写作：(i & 1) != 0。

## 1.2    谜题2：找零时刻

并不是所有的小数都可以用二进制浮点数来精确表示的。

浮点运算在一个范围很广的值域上提供了很好的近似，但是它通常不能产生精确的结果。二进制浮点对于货币计算是非常不适合的，因为它不可能将0.1——或者10的其它任何次负幂——精确表示为一个长度有限的二进制小数。

一定要用BigDecimal(String)构造器，而千万不要用BigDecimal(double)。后一个构造器将用它的参数的“精确”值来创建一个实例。

在需要精确答案的地方，要避免使用float和double；对于货币计算，要使用int、long或BigDecimal。

对于语言设计者来说，应该考虑对小数运算提供语言支持。一种方式是提供对操作符重载的有限支持，以使得运算符可以被塑造为能够对数值引用类型起作用，例如BigDecimal。另一种方式是提供原始的小数类型，就像COBOL与PL/I所作的一样。

## 1.3    谜题3：长整除

Java不具有目标确定类型的特性（指存储结果的变量的类型会影响到计算所使用的类型）。

操作很大的数字时，要提防缄默溢出。即使用来保存结果的变量已显得足够大，也并不意味着要产生结果的计算具有正确的类型。

对语言设计者来说，也许降低缄默溢出产生的可能性确实是值得做的一件事。这可以通过对不会产生缄默溢出的运算提供支持来实现。程序可以抛出一个异常而不是直接溢出，就像Ada所作的那样，或者它们可以在需要的时候自动地切换到一个更大的内部表示上以防止溢出，就像Lisp所作的那样。这两种方式都可能会遭受与其相关的性能方面的损失。降低缄默溢出的另一种方式是支持目标确定类型，但是这么做会显著地增加类型系统的复杂度。

## 1.4    谜题4：初级问题

小写字母l和数字1在大多数打字机字体中都是几乎一样的。为避免程序的读者对二者产生混淆，千万不要使用小写的l来作为long型字面常量的结尾或是作为变量名。

Java从C编程语言中继承良多，包括long型字面常量的语法。也许当初允许用小写的l来编写long型字面常量本身就是一个错误。

## 1.5    谜题5：十六进制的趣事

十进制字面常量具有一个很好的属性，即所有的十进制字面常量都是正的，而十六进制或是八进制字面常量并不具备这个属性。

一个负的十进制常量可以使用一元取反操作符（-）连接一个十进制字面常量。以这种方式，可以用十进制来书写任何int或long型的数值，不管它是正的还是负的，并且负的十进制常数可以很明确地用一个减号符号来标识。但是十六进制和八进制字面常量并非如此，它们可以具有正的以及负的数值。如果十六进制和八进制字面常量的最高位被置位了，那么它们就是负数。

混合类型的计算（mixed-type computation）可能会产生混淆，尤其是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值。为了避免这种窘境，通常最好是避免混合类型的计算。

对于语言的设计者们来说，应该考虑支持无符号的整数类型，从而根除符号扩展的可能性。

## 1.6    谜题6：多重转型

从byte到char不是一个拓宽原始类型的转换，而是一个拓宽并窄化原始类型的转换（widening and narrowing primitive conversion）：byte-> int->char。

符号扩展简单规则：如果最初的数值类型是有符号的，那么就执行符号扩展；如果它是char，那么不管它将要被转换成什么类型，都执行零扩展。

l   将一个char数值c转型为一个宽度更宽的类型，并且不希望有符号扩展，那么为清晰表达意图，可以考虑使用一个位掩码，即使它并不是必需的：int i = c & 0xffff；或者注释描述转换行为：int i = c; // 零扩展。

l   将一个char数值c转型为一个宽度更宽的整型，并且希望有符号扩展，那么就先将char转型为一个short，它与char具有同样的宽度，但是它是有符号的，并应该注释转换行为：int i = (short)c; // 符号扩展。

l   将一个byte数值b转型为一个char，并且不希望有符号扩展，那么必须使用一个位掩码来限制它：char c = (char)(b & 0xff); 

## 1.7    谜题7：互换内容

x ^= y ^= x ^= y; 不能互换x和y的值。

Java语言规范描述道：操作符的操作数是从左向右求值的。为了求表达式x ^= expr的值，x的值是在计算expr之前被提取的。x ^= y ^= x ^= y; 中，变量x的值被提取了两次，但是都发生在所有赋值操作之前。

在C和C++中，并没有指定表达式的计算顺序。当编译表达式x ^= expr时，许多C和C++编译器都是在计算expr之后才提取x的值的，这就使得上述的惯用法可以正常运转。尽管它可以正常运转，但是它仍然违背了C/C++有关不能在两个连续的序列点之间重复修改变量的规则。因此，这个惯用法的行为在C和C++中也没有明确定义。

在单个的表达式中不要对相同的变量赋值两次。表达式如果包含对相同变量的多次赋值，就会引起混乱，并且很少能够执行你希望的操作。即使对多个变量进行赋值也很容易出错。更一般地讲，要避免所谓聪明的编程技巧。它们都是易于产生bug的，很难以维护，并且运行速度经常是比它们所替代掉的简单直观的代码要慢。

语言设计者可能会考虑禁止在一个表达式中对相同的变量多次赋值，但是在一般的情况下，强制执行这条禁令会因为别名机制的存在而显得很不灵活。例如，请考虑表达式 x = a[i]++ - a[j]++，它是否递增了相同的变量两次呢？这取决于在表达式被计算时i和j的值，并且编译器通常是无法确定这一点。

## 1.8    谜题8：Dos Equis

条件操作符/问号冒号操作符（?:）

混合类型的计算会引起混乱，而这一点在条件表达式中比在其它任何地方都表现得更明显。

确定条件表达式结果类型的简单规则：

l   如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型。换句话说，可以通过绕过混合类型的计算来避免大麻烦。

l   如果一个操作数的类型是T，T表示byte、short或char，而另一个操作数是一个int类型的常量表达式，它的值是可以用类型T表示的，那么条件表达式的类型就是T。

l   否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型。

## 1.9    谜题9：半斤

复合赋值操作符包括 +=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、^=、|=

复合赋值 E1 op= E2等价于简单赋值E1 = (T)((E1)op(E2))，其中T是E1的类型，除非E1只被计算一次。

复合赋值表达式自动地将它们所执行的计算的结果转型为其左侧变量的类型。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。然而，如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原始类型转换。

不要将复合赋值操作符作用于byte、short或char类型的变量上。在将复合赋值操作符作用于int类型的变量上时，要确保表达式右侧不是long、float或double类型。在将复合赋值操作符作用于float类型的变量上时，要确保表达式右侧不是double类型。这些规则足以防止编译器产生危险的窄化转型。

对语言设计者来说，也许让复合赋值操作符产生一个不可见的转型本身就是一个错误；对于在复合赋值中的变量类型比计算结果窄的情况，也许应该让其非法才对。

## 1.10              谜题10：八两

复合赋值操作符比简单赋值操作符的限制要少一些。在一般情况下，这是对的，但是有这么一个领域，在其中简单赋值操作符会显得更宽松一些。

复合赋值操作符要求两个操作数都是原始类型的，例如int，或包装了的原始类型，例如Integer，但是有一个例外：如果在+=操作符左侧的操作数是String类型的，那么它允许右侧的操作数是任意类型，在这种情况下，该操作符执行的是字符串连接操作。简单赋值操作符（=）允许其左侧的是对象引用类型，这就显得要宽松许多了：你可以使用它们来表示任何你想要表示的内容，只要表达式的右侧与左侧的变量是赋值兼容的即可。

对语言设计者来说，加法的复合赋值操作符应该在右侧是String类型的情况下，允许左侧是Object类型。

# 2.        字符谜题

## 2.1    谜题11：最后的笑声

\+ 操作符当且仅当它的操作数中至少有一个是String类型时，才会执行字符串连接操作；否则，它执行的就是加法。

如果要对非字符类型进行字符连接行为，可以：

* 预置一个空字符串； 
* 将第一个数值用String.valueOf显式地转换成一个字符串； 
* 使用一个字符串缓冲区；
* JDK5.0+，用printf方法

操作符重载，即使在Java中只在有限的范围内得到了支持，它仍然会引起混淆。为字符串连接而重载 + 操作符可能就是一个已铸成的错误。

## 2.2    谜题12：ABC

尽管char是一个整数类型，但是许多类库都对其进行了特殊处理，因为char数值通常表示的是字符而不是整数。例如，将一个char数值传递给println方法会打印出一个Unicode字符而不是它的数字代码。字符数组受到了相同的特殊处理：println的char[]重载版本会打印出数组所包含的所有字符，而String.valueOf和StringBuffer.append的char[]重载版本的行为也是类似的。

字符串连接操作符在这些方法中没有被定义。该操作符被定义为先对它的两个操作数执行字符串转换，然后将产生的两个字符串连接到一起。对包括数组在内的对象引用的字符串转换定义如下[JLS 15.18.1.1]：  

如果引用为null，它将被转换成字符串"null"。否则，该转换的执行就像是不用任何参数调用该引用对象的toString方法一样；但是如果调用toString方法的结果是null，那么就用字符串"null"来代替。

（非空）数组是从Object那里继承的toString方法，返回一个字符串，它包含了该对象所属类的名字，'@'符号，以及表示对象散列码的一个无符号十六进制整数。在char[]类型的类对象上调用Class.getName方法的结果为字符串"[C"。

对语言设计者的教训是：char[]类型可能应该覆写toString方法，使其返回数组中包含的字符。更一般地讲，数组类型可能都应该覆写toString方法，使其返回数组内容的一个字符串表示。

## 2.3    谜题13：畜牧场

String类型的编译期常量是内存限定的。任何两个String类型的常量表达式，如果标明的是相同的字符序列，那么它们就用相同的对象引用来表示。

在使用字符串连接操作符时，总是将非平凡的操作数用括号括起来。

代码不应该依赖于字符串常量的内存限定机制。内存限定机制只是设计用来减少虚拟机内存占有量的，它并不是作为程序员可以使用的一种工具而设计的。

如果代码依赖于内存限定机制实现操作的正确性，那么就必须仔细地了解哪些域和参数必定是内存限定的。编译器不会去检查这些不变量，因为内存限定的和不限定的字符串使用相同的类型（String）来表示的。这些因在内存中限定字符串失败而导致的bug是非常难以探测到的。

对语言设计者来说，

l   字符串连接的优先级不应该和加法一样。这意味着重载 + 操作符来执行字符串连接是有问题的。

l   == 操作符在被应用于不可修改的类型时应该执行值比较。要实现这一点，一种方法是将 == 操作符作为equals方法的简便写法，并提供一个单独的类似于System.identityHashCode的方法来执行引用标识的比较。

## 2.4    谜题14：转义字符的溃败

Java对在字符串字面常量中的Unicode转义字符没有提供任何特殊处理。编译器在将程序解析成各种符号之前，先将Unicode转义字符转换成为它们所表示的字符。

使用被称为八进制转义字符的特殊类型的转义字符序列，将任何ASCII字符置于一个字符串字面常量或一个字符字面常量中，但是最好是尽可能地使用普通的转义字符序列。

普通的转义字符序列和八进制转义字符都比Unicode转义字符要好得多，因为与Unicode转义字符不同，转义字符序列是在程序被解析为各种符号之后被处理的。

ASCII是字符集的最小公共特性集，它只有128个字符，但是Unicode有超过65,000个字符。一个Unicode转义字符可以被用来在只使用ASCII字符的程序中插入一个Unicode字符。一个Unicode转义字符精确地等价于它所表示的字符。

Unicode转义字符被设计为用于在程序员需要插入一个不能用源文件字符集表示的字符的情况。它们主要用于将非ASCII字符置于标识符、字符串字面常量、字符字面常量以及注释中。偶尔地，Unicode转义字符也被用来在看起来颇为相似的数个字符中明确地标识其中的某一个，从而增加程序的清晰度。

在字符串和字符字面常量中要优先选择的是转义字符序列，而不是Unicode转义字符。Unicode转义字符可能会因为它们在编译序列中被处理得过早而引起混乱。不要使用Unicode转义字符来表示ASCII字符。在字符串和字符字面常量中，应该使用转义字符序列；对于除这些字面常量之外的情况，应该直接将ASCII字符插入到源文件中。

## 2.5    谜题15：令人晕头转向的Hello

Unicode转义字符必须是良构的，即使是出现在注释中也是如此。

在注释中插入一个良构的Unicode转义字符是合法的，但是我们几乎没有什么理由去这么做。程序员有时会在JavaDoc注释中使用Unicode转义字符来在文档中生成特殊的字符。

要确保字符\u不出现在一个合法的Unicode转义字符上下文之外，即使是在注释中也是如此。在机器生成的代码中要特别注意此问题。

## 2.6    谜题16：行打印程序

行分隔符（line separator）是为用来分隔文本行的字符或字符组合而起的名字，并且它在不同的平台上是存在差异的。在Windows平台上，它是CR字符（回车）和紧随其后的LF字符（换行）组成的，而在UNIX平台上，通常单独的LF字符被当作换行字符来引用。

编译器不仅会在将程序解析成为符号之前把Unicode转义字符转换成它们所表示的字符，而且它是在丢弃注释和空格之前做这些事的。

## 2.7    谜题17：嗯？

Unicode转义字符只有在向程序中插入用其他任何方式都无法表示的字符时才是必需的，除此之外的任何情况都应该避免使用它们。Unicode转义字符降低了程序的清晰度，并且增加了产生bug的可能性。

对语言的设计者来说，也许使用Unicode转义字符来表示ASCII字符应该被定义为是非法的。

## 2.8    谜题18：字符串奶酪

String(byte[])构造器，规范描述道：“在通过解码使用平台缺省字符集的指定byte数组来构造一个新的String时，该新String的长度是字符集的一个函数，因此，它可能不等于byte数组的长度。当给定的所有字节在缺省字符集中并非全部有效时，这个构造器的行为是不确定的”。

到底什么是字符集？从技术角度上讲，它是“被编码的字符集合和字符编码模式的结合物”。换句话说，字符集是一个包，包含了字符、表示字符的数字编码以及在字符编码序列和字节序列之间来回转换的方式。转换模式在字符集之间存在着很大的区别：某些是在字符和字节之间做一对一的映射，但是大多数都不是这样。

J2SE运行期环境（JRE）的缺省字符集依赖于底层的操作系统和语言。如果你想知道你的JRE的缺省字符集，并且你使用的是5.0或更新的版本，那么你可以通过调用java.nio.charset.Charset.defaultCharset()来了解。如果你使用的是较早的版本，那么你可以通过阅读系统属性“file.encoding”来了解。

Charset的规范要求Java平台的每一种实现都要支持某些种类的字符集，ISO-8859-1就位列其中。

每当要将一个byte序列转换成一个String时，都在使用某一个字符集，不管是否显式地指定了它。如果想让程序的行为是可预知的，那么就请在每次使用字符集时都明确地指定。

对API的设计者来说，提供一个依赖于缺省字符集的String(byte[])构造器可能并非是一个好主意。

## 2.9    谜题19：漂亮的火花

注释内部的文本没有以任何方式进行特殊处理。因此，块注释不能嵌套。

代码段被一个布尔表达式为常量false的if语句禁用了，语言规范建议将这种方式作为一种条件编译技术，但是它不适合用来注释代码。除非要被禁用的代码是一个合法的语句序列，否则就不要使用这项技术。

注释掉一个代码段的最好的方式是使用单行的注释序列。

块注释不能可靠地注释掉代码段，应该用单行的注释序列来代替。

对语言设计者来说，应该注意到可嵌套的块注释并不是一个好主意。他们强制编译器去解析块注释内部的文本，而由此引发的问题比它能够解决的问题还要多。

## 2.10              谜题20：我的类是什么？

String.replaceAll接受了一个正则表达式作为它的第一个参数，而并非接受了一个字符序列字面常量。

要想只匹配句点符号，在正则表达式中的句点必须在其前面添加一个反斜杠（\）进行转义。因为反斜杠字符在字面含义的字符串中具有特殊的含义——它标识转义字符序列的开始——因此反斜杠自身必须用另一个反斜杠来转义，这样就可以产生一个转义字符序列，它可以在字面含义的字符串中生成一个反斜杠。

5.0版本提供了新的静态方法java.util.regex.Pattern.quote。它接受一个字符串作为参数，并可以添加必需的转义字符，它将返回一个正则表达式字符串，该字符串将精确匹配输入的字符串。

## 2.11              谜题21：我的类是什么？II

String.replaceAll的第二个参数不是一个普通的字符串，而是一个替代字符串（replacement string），就像在java.util.regex规范中所定义的那样[Java-API]。在替代字符串中出现的反斜杠会把紧随其后的字符进行转义，从而导致其被按字面含义而处理了。

正则表达式是很棘手的：它所引发的问题趋向于在运行时刻而不是在编译时刻暴露出来。

对API的设计者来说，使用方法具名的模式来以明显的方式区分方法行为的差异是很重要的。Java的String类就没有很好地遵从这一原则。

## 2.12              谜题22：URL的愚弄

语句标号（statement label）

行尾注释（end-of-line comment）

令人误解的注释和无关的代码会引起混乱。要仔细地写注释，并让它们跟上时代；要切除那些已遭废弃的代码。还有就是如果某些东西看起来过于奇怪，以至于不像对的，那么它极有可能就是错的。

## 2.13              谜题23：不劳无获

Random.nextInt(int)的规范描述道：“返回一个伪随机的、均等地分布在从0（包括）到指定的数值（不包括）之间的一个int数值”

栅栏柱错误（fencepost error）

不论switch表达式为何值，该程序都将执行其相对应的case以及所有后续的case。

在switch的各种情况中缺少break语句是非常常见的错误。从5.0版本起，javac提供了-Xlint:fallthrough标志，当你忘记在一个case与下一个case之间添加break语句是，它可以生成警告信息。不要从一个非空的case向下进入了另一个case。这是一种拙劣的风格，因为它并不常用，因此会误导读者。十次中有九次它都会包含错误。如果Java不是模仿C建模的，那么它倒是有可能不需要break。对语言设计者的教训是：应该考虑提供一个结构化的switch语句。

# 3.        循环谜题

## 3.1    谜题24：尽情享受每一个字节

混合类型比较（mixed-type comparison）

由于系统总是强制地将一个操作数提升到与另一个操作数相匹配的类型，所以混合类型比较总是容易把人搞糊涂。这种转换是不可视的，而且可能不会产生期望的结果。

要避免混合类型比较，因为它们内在地容易引起混乱。

使用声明的常量替代“魔幻数字”。

## 3.2    谜题25：无情的增量操作

当++操作符被置于一个变量值之后时，其作用就是一个后缀增量操作符（postfix increment operator）。

不要在单个的表达式中对相同的变量赋值超过一次。对相同的变量进行多次赋值的表达式会产生混淆，并且很少能够产生所希望的行为。

## 3.3    谜题26：在循环中

如果需要的循环会迭代到int数值的边界附近时，最好是使用一个long变量作为循环索引。

如果在所有的（或者几乎所有的）int数值上迭代，那么使用int类型的循环索引的速度大约可以提高一倍。

对语言设计者来说，应该对那些不会在产生溢出时而不抛出异常的算术运算提供支持；应该对那些在整数值范围之上进行迭代的循环进行特殊设计，就像许多其他语言所做的那样。

## 3.4    谜题27：变幻莫测的i值

移位操作符之使用其右操作数的低5或6位（int或long）作为移位长度。这条规则作用于全部的三个移位操作符：<<、>>和>>>。移位长度总是介于0到31或63之间。这个长度是对32或64取余的。如果试图对一个int或long数值移位32或64位，只能返回这个数值自身的值。没有任何移位长度可以让一个int或long数值丢弃其所有的32位或64位。

如果可能的话，移位长度应该是常量。

右移操作符总是起到右移的作用，而左移操作符也总是起到左移的作用。负的移位长度通过只保留低5位或6位而剔除其他位的方式被转换成了正的移位长度。

对语言设计者来说，可能应该考虑将移位长度限制在从0到以位为单位的类型尺寸的范围内，并且修改移位长度为类型尺寸时的语义，让其返回0。但是可能会带来负面的执行结果，因为Java的移位操作符的语义正是许多处理器上的移位指令的语义。

## 3.5    谜题28：循环者

一个浮点数值越大，它和其后继数值之间的间隔就越大。浮点数的这种分布是用固定数量的有效位来表示它们的必然结果。对一个足够大的浮点数加1不会改变它的值，因为1是不足以“填补它与其后继者之间的空隙”。

一个浮点数值越大，它和其后继数值之间的间隔就越大。浮点数的这种分布是用固定数量的有效位来表示它们的必然结果。对一个足够大的浮点数加1不会改变它的值，因为1是不足以“填补它与其后继者之间的空隙”。

浮点数操作返回的是最接近其精确的数学结果的浮点数值。一旦毗邻的浮点数值之间的距离大于2，那么对其中的一个浮点数值加1将不会产生任何效果，因为其结果没有达到两个数值之间的一半。对于float类型，加1不会产生任何效果的最小级数是2^25，即33,554,432；而对于double类型，最小级数是2^54，大约是1.8 × 10^16。

毗邻的浮点数值之间的距离被称为一个ulp，它是“最小单位（unit in the last place）”的首字母缩写词。在5.0版中，引入了Math.ulp方法来计算float或double数值的ulp。

二进制浮点算术只是对实际算术的一种近似。

## 3.6    谜题29：循环者的新娘

NaN不等于任何浮点数值，包括它自身在内。

任何浮点操作，只要它的一个或多个操作数为NaN，那么其结果为NaN。

一旦一个计算产生了NaN，它就被损坏了，没有任何更进一步的计算可以修复这样的损坏。NaN值意图使受损的计算继续执行下去，直到方便处理这种情况的地方为止。

## 3.7    谜题30：循环者的爱子

唯一的 + 操作符有定义的非数值类型就是String。+ 操作符被重载了：对于String类型，它执行的不是加法而是字符串连接。如果在连接中的某个操作数具有非String的类型，那么这个操作书就会在连接之前转换成字符串。

对语言设计者来说，操作符重载是很容易引起混乱的，也许 + 操作符就不应该被重载用来进行字符串连接操作。有充分的理由证明提供一个字符串连接操作符是多么必要，但是它不应该是 +。

## 3.8    谜题31：循环者的鬼魂

复合赋值操作符包括*=、/=、%=、+=、-=、<<=、>>=、>>>=、&=、^=和|=。

复合赋值操作符可能会自动地执行窄化原始类型转换。

不要在short、byte或char类型的变量之上使用复合赋值操作符。因为这样的表达式执行的是混合类型算术运算，它容易造成混乱。更糟的是，它们执行将隐式地执行会丢失信息的窄化转型，其结果是灾难性的。

对语言设计者的教训是语言不应该自动地执行窄化转换。还有一点值得好好争论的是，Java是否应该禁止在short、byte和char变量上使用复合赋值操作符。

## 3.9    谜题32：循环者的诅咒

Java的<=操作符在5.0版之前是反对称的，但是这从5.0版之后就不再是了。

直到5.0版之前，Java的数字比较操作符（<、<=、>和>=）要求它们的两个操作数都是原始数字类型的（byte、char、short、int、long、float和double）。但是在5.0版中，规范作出了修改，新规范描述道：每一个操作数的类型必须可以转换成原始数字类型。

在5.0版中，自动包装（autoboxing）和自动反包装（auto-unboxing）被添加到了Java语言中。<=操作符在原始数字类型集上仍然是反对称的，但是现在它还被应用到了被包装的数字类型上。（被包装的数字类型有：Byte、Character、Short、Integer、Long、Float和Double。）<=操作符在这些类型的操作数上不是反对称的，因为Java的判等操作符（==和!=）在作用于对象引用时，执行的是引用ID的比较，而不是值的比较。

为什么语言规范没有修改为：当判等操作符作用于被包装的数字类型时，它们执行的是值比较。答案很简单：兼容性。当一种语言被广泛使用之后，以违反现有规范的方式去改变现有程序的行为是让人无法接受的。

判等操作符在其两个操作数中只有一个是被包装的数字类型，而另一个是原始类型时，执行的确实是数值比较。因为这在5.0版之前是非法的，所有在这里没有任何兼容性的问题。

当两个操作数都是被包装的数字类型时，数值比较操作符和判等操作符的行为存在着根本的差异：数值比较操作符执行的是值比较，而判等操作符执行的是引用标识的比较。

语言设计者应该考虑语言可能会如何演化，并且应该努力去最小化在演化之路上的各种制约影响。

## 3.10              谜题33：循环者遇到了狼人

一元减号操作符作用于一个非数字型操作数是非法的。

没有任何一种Java数值类型能够对实数进行完美建模。浮点数值是用一个符号位、一个被通俗地称为尾数（mantissa）的有效数字以及一个指数来表示的。除了0之外，没有任何浮点数等于其符号位反转之后的值。

有符号的整数类型使用的是2的补码算术运算：为了对一个数值取其负值，要反转其每一位，然后加1，从而得到结果。2的补码算术运算的一个很大的优势是，0具有唯一的表示形式。如果要对int数值0取负值，将得到0xffffffff+1，它仍然是0。

总共存在偶数个int数值——准确地说有2^32个——其中一个用来表示0，这样就剩些奇数个int数值来表示正整数和负整数，这意味着正的和负的int数值的数量必然不相等。这暗示着至少有一个int数值，其负值不能正确地表示成为一个int数值。

Integer.MIN_VALUE是它自己的负值，Long.MIN_VALUE也是一样。对这两个值取负值将会产生溢出，但是Java在整数计算中忽略了溢出。

Java使用2的补码的算术运算，它是非对称的。对于每一种有符号的整数类型（int、long、byte和short），负的数值总是比正的数值多一个，这个多出来的值总是这种类型所能表示的最小数值。

对语言设计者来说，应该对某种溢出不会悄悄发生的整数算术运算形式提供语言级的支持。

## 3.11              谜题34：被计数击倒了

float类型只能提供24位的精度。

在将一个int与一个float进行比较时，会自动执行从int到float的提升。遗憾的是，这种提升是会导致精度丢失的三种拓宽原始类型转换的一种。（另外两个是从long到float和从long到double。）

不要使用浮点数作为循环索引，因为它会导致无法预测的行为。如果在循环体内需要一个浮点数，那么请使用int或long循环索引，并将其转换为float或double。在将一个int或long转换成一个float或double时，可能会丢失精度，但是至少它不会影响到循环本身。当使用浮点数时，要使用double而不是float，除非肯定float提供了足够的精度，并且存在强制性的性能需求迫使使用float。适合使用float而不是double的时刻是非常非常少的。

对语言设计者来说，悄悄地丢失精度对程序员来说是非常令人迷惑的。

## 3.12              谜题35：一分钟又一分钟

取余和乘法操作符具有相同的优先级。

编译器是忽略空格的，所以千万不要使用空格来表示分组，要使用括号。

# 4.        异常谜题

## 4.1    谜题36：优柔寡断

在一个try-finally语句中，finally语句块总是在控制权离开try语句块时执行的。无论try语句块是正常结束的，还是意外结束的，情况都是如此。一条语句或一个语句块在它抛出了一个异常，或者对某个封闭型语句执行了一个break或continue，或是象这个程序一样在方法中执行了一个return时，将发生意外结束。它们之所以被称为意外结束，是因为它们阻止程序去按顺序执行下面的语句。

当try语句块和finally语句块都意外结束时，在try语句块中引发意外结束的原因将被丢弃，而整个try-finally语句意外结束的原因将于finally语句块意外结束的原因相同。

每一个finally语句块都应该正常结束，除非抛出的是不受检查的异常。千万不要用一个return、break、continue或throw来退出一个finally语句块，并且千万不要允许将一个受检查的异常传播到一个finally语句块之外去。

对于语言设计者来说，也许应该要求finally语句块在未出现不受检查的异常时必须正常结束。朝着这个目标，try-finally结构将要求finally语句块可以正常结束。return、break或continue语句把控制权传递到finally语句块之外应该是被禁止的，任何可以引发将被检查异常传播到finally语句块之外的语句也同样应该是被禁止的。

## 4.2    谜题37：极端不可思议

如果一个catch子句要捕获一个类型为E的被检查异常，而其相对应的try子句不能抛出E的某种子类型的异常，那么这就是一个编译期错误。

JLS在这一点上十分含混不清，但是捕获Exception或Throwble的catch子句是合法的，不管与其相对应的try子句的内容为何。

每一个接口都限制了方法可以抛出的被检查异常集合。一个方法可以抛出的被检查异常集合是它所适用的所有类型声明要抛出的被检查异常集合的交集，而不是合集。

对于捕获被检查异常的catch子句，只有在相应的try子句可以抛出这些异常时才被允许。

多个继承而来的throws子句的交集，将减少而不是增加方法允许抛出的异常数量。

## 4.3    谜题38：不受欢迎的宾客

空final（blank final），它是一个在声明中没有进行初始化操作的final域。

要确定一个程序是否可以不止一次地对一个空final进行赋值是一个很困难的问题。事实上，这是不可能的。这等价于经典的停机问题，它通常被认为是不可能解决的。为了能够编写出一个编译器，语言规范在这一点上采用了保守的方式。在程序中，一个空final域只有在它是明确未赋过值的地方才可以被赋值。规范长篇大论，对此术语提供了一个准确的但保守的定义。因为它是保守的，所以编译器必须拒绝某些可以证明是安全的程序。

## 4.4    谜题39：您好，再见！

System.exit方法将停止当前线程和所有其他当场死亡的线程。finally子句的出现并不能给予线程继续去执行的特殊权限。

当System.exit被调用时，虚拟机在关闭前要执行两项清理工作。首先，它执行所有的关闭挂钩操作，这些挂钩已经注册到了Runtime.addShutdownHook上。这对于释放VM之外的资源将很有帮助。务必要为那些必须在VM退出之前发生的行为关闭挂钩。

VM执行在System.exit被调用时执行的第二个清理任务与终结器有关。如果System.runFinalizerOnExit或它的魔鬼双胞胎Runtime.runFinalizersOnExit被调用了，那么VM将在所有还未终结的对象上面调用终结器。这些方法很久以前就已经过时了，而且其原因也很合理。无论什么原因，永远不要调用System.runFinalizersOnExit和Runtime.runFinalizersOnExit：它们属于Java类库中最危险的方法之一[ThreadStop]。调用这些方法导致的结果是，终结器会在那些其他线程正在并发操作的对象上面运行，从而导致不确定的行为或导致死锁。

System.exit将立即停止所有的程序线程，它并不会使finally语句块得到调用，但是它在停止VM之前会执行关闭挂钩操作。当VM被关闭时，请使用关闭挂钩来终止外部资源。通过调用System.halt可以在不执行关闭挂钩的情况下停止VM，但是这个方法很少使用。

## 4.5    谜题40：不情愿的构造器

当调用一个构造器时，实例变量的初始化操作将先于构造器的程序体而运行。

实例初始化操作是先于构造器的程序体而运行的。实例初始化操作抛出的任何异常都会传播给构造器。如果初始化操作抛出的是被检查异常，那么构造器必须声明也会抛出这些异常，但是应该避免这样做，因为它会造成混乱。最后，对于我们所设计的类，如果其实例包含同样属于这个类的其他实例，那么对这种无限递归要格外当心。

## 4.6    谜题41：域和流

在finally语句块中调用close方法时，要用一个嵌套的try-catch语句来保护它，以防止IOException的传播。更一般地讲，对于任何在finally语句块中可能会抛出的被检查异常都要进行处理，而不是任其传播。

## 4.7    谜题42：异常为循环而抛

不要使用异常来进行循环控制；应该只为异常条件而使用异常。

除了常见的被当作整型操作数的位AND操作符之外，当被用于布尔操作数时，它的功能被重载为逻辑AND操作符。这个操作符与更经常被使用的条件AND操作符有所不同，& 操作符总是要计算它的两个操作数，而 && 操作符在其左边的操作数被计算为false时，就不再计算右边的操作数了。

对语言设计者来说，对于在条件AND和OR操作符之外还要提供逻辑AND和OR操作符这一点，并没有很明显的理由。如果这些操作符确实要得到支持的话，它们应该与其相对应的条件操作符存在着视觉上的明显差异。

## 4.8    谜题43：异常地危险

Class.newInstance方法存在设计缺陷，该方法将传播从空的（即无参数的）构造器所抛出的任何异常，包括受检查的异常。使用这个方法可以有效地绕开在其他情况下都会执行的编译期异常检查。Constructor.newInstance方法通过将构造器抛出的任何异常都包装在一个（受检查的）InvocationTargetException异常中而避免了这个问题。Class.newInstance应该是做了相同的处理，但是纠正这个缺陷已经为时过晚，因为这么做将引入源代码级别的不兼容性，这将使许多依赖于Class.newInstance的程序崩溃。而弃用这个方法也不切实际，因为它太常用了。在使用它时，一定要意识到Class.newInstance可以抛出它没有声明过的受检查异常。

为了实现最大的兼容性，通用类型（generics）是通过类型擦除（type erasure）来实现的：通用类型信息是在编译期而非运行期检查的。

Java的异常检查机制并不是虚拟机强制执行的。它只是一个编译期工具，被设计用来帮助我们更加容易地编写正确的程序，但是在运行期可以绕过它。

## 4.9    谜题44：切掉类

NoClassDefFoundError可以在（直接或间接）使用某个类的程序中的任何地方”抛出。

为了运行一个程序，VM要加载和初始化包含main方法的类。在加载和初始化之间，VM必须链接（link）类。链接的第一阶段是校验，校验要确保一个类是良构的，并且遵循语言的语法要求。校验非常关键，它维护着可以将像Java这样的安全语言与像C或C++这样的不安全语言区分开的各种承诺。

要想编写一个能够探测出某个类是否丢失的程序，请使用反射来引用类而不要使用通常的语言结构。

不要对捕获NoClassDefFoundError形成依赖。语言规范非常仔细地描述了类初始化是在何时发生的，但是类被加载的时机却显得更加不可预测。更一般地讲，捕获Error及其子类型几乎是完全不恰当的。这些异常是为那些不能被恢复的错误而保留的。

## 4.10              谜题45：令人疲惫不堪的测验

Java虚拟机对栈的深度限制到了某个预设的水平。当超过这个水平时，VM就抛出StackOverflowError。

# 5.        类谜题

## 5.1    谜题46：令人混淆的构造器案例

Java的重载解析过程是以两阶段运行的。第一阶段选取所有可获得并且可应用的方法或构造器。第二阶段在第一阶段选取的方法或构造器中选取最精确的一个。如果一个方法或构造器可以接受传递给另一个方法或构造器的任何参数，那么第一个方法比第二个方法缺乏精确性。

一旦编译器确定了哪些重载版本是可获得且可应用的，它就会选择最精确的一个重载版本，而此时使用的仅仅是形式参数：即出现在声明中的参数。

要想强制要求编译器选择一个精确的重载版本，需要将实际的参数转型为形式参数所声明的类型。

理想状态下，应该避免使用重载：为不同的方法取不同的名称。当然，有时候这无法实现，例如，构造器就没有名称，因而也就无法被赋予不同的名称。然而，可以通过将构造器设置为私有的并提供公有的静态工厂，以此来缓解这个问题。如果构造器有许多参数，可以用Builder模式来减少对重载版本的需求量。

如果确实进行了重载，那么请确保所有的重载版本所接受的参数类型都互不兼容，这样，任何两个重载版本都不会同时是可应用的。如果做不到这一点，那么就请确保所有可应用的重载版本都具有相同的行为。

## 5.2    谜题47：啊呀！我的猫变成狗了

在设计一个类的时候，如果该类构建于另一个类的行为之上，那么有两种选择：一种是继承，即一个类扩展另一个类；另一种是组合，即在一个类中包含另一个类的一个实例。选择的依据是，一个类的每一个实例都是另一个类的一个实例，还是都有另一个类的一个实例。在第一种情况应该使用继承，而第二种情况应该使用组合。当拿不准时，优选组合而不是继承。

## 5.3    谜题48：我所得到的都是静态的

对静态方法的调用不存在任何动态的分派机制。

当一个程序调用了一个静态方法时，要被调用的方法都是在编译时刻被选定的，而这种选定是基于修饰符的编译期类型而做出的，修饰符的编译期类型就是给出的方法调用表达式中圆点左边部分的名字。

静态方法是不能被覆写的；它们只能被隐藏。

对语言设计者来说：对类和实例方法的调用彼此之间看起来应该具有明显的差异。第一种实现此目标的方式是不允许使用表达式作为静态方法的修饰符；第二种区分静态方法和实例方法调用的方式是使用不同的操作符，就像C++那样；第三种方式是通过完全抛弃静态方法这一概念来解决此问题，就像Smalltalk那样。

## 5.4    谜题49：比生命更大

在final类型的静态域被初始化之前，存在着读取它的值的可能，而此时该静态域包含的还只是其所属类型的缺省值。

final类型的域只有在其初始化表达式是常量表达式时才是常量。

某些通用的设计模式本质上就是初始化循环的，如单例模式（Singleton）和服务提供者框架（Service Provider Framework）。类型安全的枚举模式（Typesafe Enum pattern）也会引起类初始化的循环。5.0版本添加了对这种使用枚举类型的模式的语言级支持。为了减少问题发生的可能性，对枚举类型的静态初始器做了一些限制。

要当心类初始化循环。最简单的循环只涉及到一个单一的类，但是它们也可能涉及多个类。类初始化循环也并非总是坏事，但是它们可能会导致在静态域被初始化之前就调用构造器。静态域，甚至是final类型的静态域，可能会在它们被初始化之前，被读走其缺省值。

## 5.5    谜题50：不是你的类型

尽管null对于每一个引用类型来说都是其子类型，但是instanceof操作符被定义为在其左操作数为null时返回false。

如果instanceof明确一个对象引用是某个特定类型的实例，那么就可以将其转型为该类型，并调用该类型的方法，而不用担心会抛出ClassCastException或NullPointerException异常。

instanceof操作符要求：如果两个操作数的类型都是类，其中一个必须是另一个的子类型。

如果在一个转型操作中的两种类型都是类，那么其中一个必须是另一个的子类型。

## 5.6    谜题51：那个点是什么？

不可变的值类（value class），值类即其实例表示值的类。

在一个final类型的实例域被赋值之前，存在着取用其值的可能，而此时它包含的仍旧是其所属类型的缺省值。

循环类初始化是无法避免的灾难，但是循环实例初始化总是可以且总是应该避免的。

无论何时，只要一个构造器调用了一个已经被其子类覆写了的方法，那么循环实例初始化就会出现，因为以这种方式被调用的方法总是在实例被初始化之前执行。要想避免这个问题，就千万不要在构造器中调用可覆写的方法，直接调用或间接调用都不行[EJ Item 15]。这项禁令应该扩展至实例初始器和伪构造器（pseudoconstructors）readObject与clone。（这些方法之所以被称为伪构造器，是因为它们可以在不调用构造器的情况下创建对象。）

尽管惰性加载可以订正循环实例初始化问题，但是对于让一个值类去扩展另一个值类，并且在其中添加一个会对euqals比较方法产生影响的域的这种做法仍旧不是一个好主意。无法在超类和子类上都提供一个基于值的equals方法，而同时又不违反Object.equals方法的通用约定，或者是不消除在超类和子类之间进行有实际意义的比较操作的可能性。

不要在构造器中调用可覆 写的方法。在实例初始化中产生的循环将是致命的。该问题的解决方案就是惰性初始化。

## 5.7    谜题52：合计数的玩笑

要么使用积极初始化，要么使用惰性初始化，但是千万不要同时使用二者。

如果初始化一个域的时间和空间代价比较低，或者该域在程序的每一次执行中都需要用到时，那么使用积极初始化是恰当的。如果其代价比较高，或者该域在某些执行中并不会被用到，那么惰性初始化可能是更好的选择。另外，惰性初始化对于打破类或实例初始化中的循环也可能是必需的。

助手方法通常都优于静态语句块，因为它可以对计算命名。只有在极少的情况下，才必须使用一个静态语句块来初始化一个静态域，此时请将该语句块紧随该域声明之后放置。这提高了程序的清晰度，并且消除了像最初的程序中出现的静态初始化与静态语句块互相竞争的可能性。

## 5.8    谜题53：按你的意愿行事

交替构造器调用机制（alternate constructor invocation），允许一个类中的某个构造器链接调用同一个类中的另一个构造器。

私有构造器捕获（Private Constructor Capture）惯用法是一种非常有用的模式。

## 5.9    谜题54：Null与Void

在静态方法的调用中，使用表达式作为其限定符并非是一个好主意，而这也正是问题之所在。不仅表达式的值所引用的对象的运行期类型在确定哪一个方法将被调用时并不起任何作用，而且如果对象有标识的话，其标识也不起任何作用。

要么用某种类型来限定静态方法调用，要么就压根不要限定它们。

对语言设计者来说，应该不允许用表达式来污染静态方法调用的可能性存在，因为它们只会产生混乱。

## 5.10              谜题55：特创论

一个本地变量声明看起来像是一条语句，但是从技术上说，它不是；它应该是一个本地变量声明语句（local variable declaration statement）。Java语言规范不允许一个本地变量声明语句作为一条语句在for、while或do循环中重复执行。一个本地变量声明作为一条语句只能直接出现在一个语句块中。（一个语句块是由一对花括号以及包含在这对花括展中的语句和声明构成的。）

一个程序创建出的某个类的实例可能会多余int数值的最大值，但是它不会多于long数值的最大值。

int数值的最大值是2^(31-1)，即大约2.1×10^9，而long数值的最大值是2^(63-1)，即大约9.2×10^18。当前，每秒钟创建10^8个对象是可能的，这意味着一个程序在long类型的对象计数器溢出之前，不得不运行大约三千年。即使是面对硬件速度的提升，long类型的对象计数器也应该足以应付可预见的未来。

使用一个AtomicLong实例，在面临并发时可以绕过对同步的需求。

一个本地变量声明不能被用作for、while或do循环中的重复执行语句，它作为一条语句只能出现在一个语句块中。另外，在使用一个变量来对实例的创建进行计数时，要使用long类型而不是int类型的变量，以防止溢出。最后，如果打算在多线程中创建实例，要么将对实例计数器的访问进行同步，要么使用一个AtomicLong类型的计数器。

# 6.        库谜题

## 6.1    谜题56：大问题

BigInteger实例是不可变的。String、BigDecimal以及包装器类型：Integer、Long、Short、Byte、Character、Boolean、Float和Double也是如此，不能修改它们的值。

不可变类型更容易设计、实现和使用；它们出错的可能性更小，并且更加安全。

对API设计来说，其教训是：在命名不可变类型的方法时，应该优选介词和名词，而不是动词。介词适用于带有参数的方法，而名词适用于不带参数的方法。

## 6.2    谜题57：名字里有什么？

hashCode约定要求相等的对象要具有相同的散列码。为了遵守这项约定，无论何时，只要覆写了equals方法，就必须同时覆写hashCode方法。

从Object那里继承的hashCode实现，返回的是基于标识的散列码。换句话说，不同的对象几乎总是产生不相等的散列值，即使它们是相等的也是如此。

所有的HashSet实现都进行了一种优化，即每一项在存储元素本身之外，还存储了元素的散列值。在搜索某个元素时，这种实现通过遍历集合中的项，去拿存储在每一项中的散列值与我们想要查找的元素的散列值进行比较，从而选取适当的散列位置。只有在两个元素的散列值相等的情况下，这种实现才会认为这两个元素相等。这种优化是有实际意义的，因为比较散列码相对于比较元素来说，其代价要小得多。

被连续创建的两个对象偶尔也会具有相同的标识散列码。一个粗略的实验表明，这种偶然性出现的概率大约是25,000,000分之一。这个实验的结果可能会因所使用的Java实现的不同而有所变化，但是在任何所知的JRE上，基本上不可能出现。

当覆写equals方法时，一定要记着覆写hashCode方法。更一般地讲，在覆写一个方法时，如果它具有一个通用的约定，那么一定要遵守它。对于大多数在Object中声明的非final的方法，都需要注意这一点。不采用这项建议就会导致任意的、不确定的行为。

## 6.3    谜题58：产生它的散列码

HashSet类是使用equals(Object)方法来测试元素的相等性的。

当想要进行覆写时，千万不要进行重载。

在使用@Override注释时，除非被注释的方法确实覆写了一个超类方法，否则它将不能编译。

对语言设计者来说，值得去考虑在每一个覆写超类方法的方法声明上都添加一个强制性的修饰符。

## 6.4    谜题59：什么是差？

为以0开头的整数类型字面常量将被解释成为八进制数值。这个隐晦的结构是从C编程语言那里遗留下来东西，C语言产生于1970年代，那时八进制比现在要通用得多。

千万不要在一个整型字面常量的前面加上一个0；这会使它变成一个八进制字面常量。有意识地使用八进制整型字面常量的情况相当少见，应该对所有的这种特殊用法增加注释。

对语言设计者来说，在决定应该包含什么特性时，应该考虑到其限制条件。当有所迟疑时，应该将它剔除在外。

## 6.5    谜题60：一行的方法

Arrays.deepToString。如果你传递给它一个对象引用的数组，它将返回一个精密的字符串表示。它可以处理嵌套数组，甚至可以处理循环引用，即一个数组元素直接或间接地引用了其嵌套外层的数组。事实上，5.0版本中的Arrays类提供了一整套的toString、equals和hashCode方法，使得能够打印、比较或散列任何原始类型数组或对象引用数组的内容。

## 6.6    谜题61：日期游戏

Calendar和Date缺陷，简直就是雷区。Calendar严重问题包括弱类型（几乎每样事物都是一个int）、过于复杂的状态空间、拙劣的结构、不一致的命名以及不一致的语义等。在使用Calendar和Date的时候一定要当心，千万要记着查阅API文档。

对API设计者来说：如果你不能在第一次设计时就使它正确，那么至少应该在第二次设计时应该使它正确，绝对不能留到第三次设计时去处理。如果你对某个API的首次尝试出现了严重问题，那么你的客户可能会原谅你，并且会再给你一次机会。如果你第二次尝试又有问题，你可能会永远坚持这些错误了。

## 6.7    谜题62：名字游戏

IdentityHashMap的文档中叙述道：这个类用一个散列表实现了Map接口，它在比较键时，使用的是引用等价性而不是值等价性。

语言规范保证了字符串是内存限定的，换句话说，相等的字符串常量同时也是相同的。

不要使用IdentityHashMap，除非你需要其基于标识的语义；它不是一个通用目的的Map实现。这些语义对于实现保持拓扑结构的对象图转换（topology-preserving object graph transformations）非常有用，例如序列化和深层复制。

## 6.8    谜题63：更多同样的问题

不要因为偶然地添加了一个返回类型，而将一个构造器声明变成了一个方法声明。尽管一个方法的名字与声明它的类的名字相同是合法的，但是你千万不要这么做。更一般地讲，要遵守标准的命名习惯，它强制要求方法名必须以小写字母开头，而类名应该以大写字母开头。

对语言设计者来说，在没有任何程序员声明的构造器的情况下，自动生成一个缺省的构造器这种做法并非是一个很好的主意。如果确实生成了这样的构造器，也许应该让它们是私有的。有好几种其他的方法可以消除这个陷阱。一种方法是禁止方法名与类名相同，就像C#所作的那样，另一种是彻底消灭所有的构造器，就像Smalltalk所作的那样。

## 6.9    谜题64：按余数编组

在计算一个非负的int数值整除一个正的int数值的余数时，可以保证将产生一个非负的结果。

对于Math.abs，如果其参数等于Integer.MIN_VALUE，那么产生的结果与该参数相同，它是一个负数。Math.abs不能保证一定会返回非负的结果。

对类库的设计者来说，也许在将Integer.MIN_VALUE和Long.MIN_VALUE传递给Math.abs时，抛出IllegalArgumentException会显得更合理。

## 6.10              谜题65：一种疑似排序的惊人传奇

定长的整数没有大到可以保存任意两个同等长度的整数之差的程度。当在做两个int或long数值的减法时，其结果可能会溢出。只在用来进行比较的两个数字的差大于Integer.MAX_VALUE的时候才会出问题。

Comparator的文档说明它所实现的排序关系必须是可传递的（transitive），换句话说，(compare(x,y) > 0)&&(compare(y,z) > 0)蕴含着compare(x,z) > 0。

出于数学上的倾向性，Comparator.compare方法的一般约定要求比较器要产生一个全序（total order）。

不要使用基于减法的比较器，除非能够确保要比较的数值之间的差永远不会大于Integer.MAX_VALUE。

应该避免“聪明”的代码。应该努力去编写清晰正确的代码，不要对它作任何优化，除非该优化被证明是必需的。

对语言设计者来说，值得去考虑支持某种形式整数算数运算，它不会在溢出时不抛出异常。还有就是可能应该在语言中提供一个三值的比较器操作符，就像Perl所作的那样（<=>操作符）。

# 7.        更多的谜题

## 7.1    谜题66：一件私事

一个覆写方法的访问修饰符所提供的访问权限与被覆写方法的访问修饰符所提供的访问权限相比，至少要一样多。

对一个域来说，当它要隐藏另一个域时，如果隐藏域的访问修饰符提供的访问权限比被隐藏域的少，尽管这么做不可取的，但是它确实是合法的。事实上，对于隐藏域来说，如果它具有与被隐藏域完全无关的类型，也是合法的。

覆写与隐藏之间区别：一旦一个方法在子类中被覆写，就不能在子类的实例上调用它了（除了在子类内部，通过使用super关键字来调用方法）。然而，你可以通过将子类实例转型为某个超类类型来访问到被隐藏的域，在这个超类中该域未被隐藏。

想展示覆写行为，那么可以用公共方法来替代公共域。

Java语言允许隐藏变量、嵌套类型，甚至是静态方法。

如果一个类要隐藏一个域，而用来隐藏该域的域具有的可访问性比被隐藏域更具限制性，就像我们最初的程序那样，那么这就违反了包容性（subsumption）原则，即大家所熟知的Liskov置换原则（Liskov Substitution Principle）。

能够对基类所作的任何事，都同样能够作用于其子类。包容性是面向对象编程的自然心理模型的一个不可分割的部分。无论何时，只要违反了这项原则，就会对程序的理解造成困难。还有其它数种用另一个域来隐藏某个域的方法也会违反包容性：例如，两个域具有不同的类型；一个域是静态的而另一个域不是；一个域是final的而另一个域不是；一个域是常量而另一个域不是；以及两个域都是常量但是它们具有不同的值。

对于语言设计者而言，应该考虑消除隐藏的可能性：例如，使所有的域都隐含地是私有的。如果这样做显得过于严苛，那么至少应该考虑对隐藏进行限制，以使其遵守包容性原则。

当你在声明一个域、一个静态方法或一个嵌套类型时，如果其名字与基类中相对应的某个可访问的域、方法或类型相同，就会发生隐藏。隐藏是容易产生混乱的：违反包容性的隐藏域在某种意义上是特别有害的。更一般地讲，除了覆写之外，要避免名字重用。

## 7.2    谜题67：对字符串上瘾

要避免重用平台类的名字，并且千万不要重用java.lang中的类名，因为这些名字会被各处的程序自动加载。程序员习惯于看到这些名字以无限定的形式出现，并且会很自然地认为这些名字引用的是我们所熟知的java.lang中的类。如果你重用了这些名字的某一个，那么当这个名字在其自己的包内被使用时，该名字的无限定形式将会引用到新的定义上。

要避免重用类名，尤其是Java平台类的类名。千万不要重用java.lang包内的类名，相同的教训也适用于类库的设计者。Java平台的设计者已经在这个问题上栽过数次了，著名的例子有java.sql.Date，它与java.util.Date和org.omg.CORBA.Object相冲突。

对平台实现者来说，诊断信息应该清晰地解释失败的原因。VM应该可以很容易地将没有任何具有正确签名的main方法的情况与根本就没有任何main方法的情况区分开。

## 7.3    谜题68：灰色的阴影

当一个变量和一个类型具有相同的名字，并且它们位于相同的作用域时，变量名具有优先权。变量名将遮掩（obscure）类型名。相似地，变量名和类型名可以遮掩包名。

遵守标准的Java命名习惯的程序继续从来都不会遇上这个问题。类应该以一个大写字母开头，以MixedCase的形式书写；变量应该以一个小写字母开头，以mixedCase的形式书写；而常量应该以一个大写字母开头，以ALL_CAPS的方式书写。单个的大写字母只能用于类型参数，就像在泛型接口Map<K,V>中那样。包名应该以lower.case的方式命名。

为了避免常量名与类名的冲突，在类名中应该将首字母缩拼词当作普通的词处理[EJ Item 38]。例如，一个表示全局唯一标识符的类应该被命名为Uuid，而不是UUID，尽管其首字母缩拼词通常被写为UUID。（Java平台库就违反了这项建议，因为它具有UUID、URL和URI这样的类名。）为了避免变量名与包名的冲突，请不要使用顶层的包名或领域名作为变量的名字，特别是不要将一个变量命名为com、org、net、edu、java或javax。

对语言设计者来说，应该考虑去消除遮掩的可能性。C#是通过将域和嵌套类置于相同的命名空间来实现这一点的。

## 7.4    谜题69：黑色的渐隐

可以引用到一个被遮掩的类型名的，其技巧就是在某一种特殊的语法上下文环境中使用该名字，在该语法上下文环境中允许出现一个类型但是不允许出现一个变量。这种上下文环境包括：

在转型表达式的括号中间的部分。

在一个类声明的extends子句中。因为基类总是一种类型，出现在extends子句中的名字从来都不会被解析为变量名。

如果使用的5.0或更新的版本，在一个类型变量声明的extends子句中使用。

## 7.5    谜题70：一揽子交易

一个包内私有的方法不能被位于另一个包中的某个方法直接覆写。

包内私有的方法不能直接被包外的方法声明所覆写。尽管包内私有的访问权限和覆写结合到一起会导致某种混乱，但是Java当前的行为是允许使用包的，以支持比单个的类更大的抽象封装。包内私有的方法是它们所属包的实现细节，在包外重用它们的名字是不会对包内产生任何影响的。

## 7.6    谜题71：进口税

编译器在选择在运行期将被调用的方法时，所作的第一件事就是在肯定能找到该方法的范围内挑选。编译器将在包含了具有恰当名字的方法的最小闭合范围内进行挑选。

遮蔽(shade)与遮掩(obscure)非常相像，二者的关键区别是一个声明只能遮蔽类型相同的另一个声明：一个类型声明可以遮蔽另一个类型声明，一个变量声明可以遮蔽另一个变量声明，一个方法声明可以遮蔽另一个方法声明。与其形成对照的是，变量声明可以遮掩类型和包声明，而类型声明也可以遮掩包声明。

当一个声明遮蔽了另一个声明时，简单名将引用到遮蔽声明中的实体。本身就属于某个范围的成员在该范围内与静态导入相比具有优先权。导致的后果之一就是与Object的方法具有相同名字的静态方法不能通过静态导入工具而得到使用。

静态导入工具所专门针对的情况是：程序中会重复地使用另一个类的静态元素，而每一次用到的时候都进行限定又会使程序变得乱成一锅粥。在这类情况中，静态导入工具可以显著地提高可读性。这比通过实现接口来继承其常量要安全得多，而实现接口这种做法是从来都不应该采用的。然而，滥用静态导入工具也会损害可读性，因为这会使得静态成员的类在何处被使用显得非常不清晰。应该有节制地使用静态导入，只有在非常需要的情况下才应该使用它们。

对API设计者来说，要意识到当某个方法的名字已经出现在某个作用域内时，静态导入工具并不能被有效地作用于该方法上。这意味着静态导入不能用于那些与通用接口中的方法共享方法名的静态方法，而且也从来不能用于那些与Object中的方法共享方法名的静态方法。

## 7.7    谜题72：终极危难

final修饰符对方法和域而言，意味着某些完全不同的事情。对于方法，final意味着该方法不能被覆写（对实例方法而言）或者隐藏（对静态方法而言）。对于域，final意味着该域不能被赋值超过一次。关键字相同，但是其行为却完全不相关。

对语言设计者来说，应该避免在不相关的概念之间重用关键字。一个关键字应该只在密切相关的概念之间重用，这样可以帮助程序员构建关于易混淆的语言特性之间的关系的印象。在Java的final关键字这一案例中，重用就导致了混乱。应该注意的是，作为一种有年头的语言来说，在无关的概念之间重用关键字是它的一种自然趋势，这样做可以避免引入新的关键字，而引入新的关键字会对语言的稳定性造成极大的损害。当语言设计者在考虑该怎么做时，总是在两害相权取其轻。

要避免在无关的变量或无关的概念之间重用名字。对无关的概念使用有区别的名字有助于让读者和程序员区分这些概念。

## 7.8    谜题73：你的隐私正在公开

如果使一个类成为可序列化的，并且接受缺省的序列化形式，那么该类的私有实例域将成为其导出API的一部分。当客户正在使用现有的被序列化对象时，对私有表示的修改将会导致异常或者是错误的行为。

严格地讲，构造器不是成员。

添加一个私有类声明，由于遮蔽，可能间接地修改了一个现有公共方法的返回类型，而这是一个不兼容的API修改，因为我们修改了一个被导出API所使用的名字的含义。

被遮蔽类型也可以来自一个外围类而不是来自java.lang；可以遮蔽一个变量而不是一个类型，而被遮蔽变量可以来自一个static import声明或者是来自一个外围类。

## 7.9    谜题74：同一性的危机

无

## 7.10              谜题75：头还是尾？

条件操作符（？:）的行为在5.0版本之前是非常受限的。当第二个和第三个操作数是引用类型时，条件操作符要求它们其中的一个必须是另一个的子类型。

在5.0或更新的版本中，Java语言显得更加宽大了，条件操作符在第二个和第三个操作数是引用类型时总是合法的。其结果类型是这两种类型的最小公共超类。公共超类总是存在的，因为Object是每一个对象类型的超类型。在实际使用中，这种变化的主要结果就是条件操作符做正确的事情的情况更多了，而给出编译期错误的情况更少了。对于我们当中的语言菜鸟来说，作用于引用类型的条件操作符的结果所具备的编译期类型与在第二个和第三个操作数上调用下面的方法的结果相同：  

 T choose(T a,T b) { }

**名字重用的术语表**

**覆写（override****）**

一个实例方法可以覆写（override）在其超类中可访问到的具有相同签名的所有实例方法，从而使能了动态分派（dynamic dispatch）；换句话说，VM将基于实例的运行期类型来选择要调用的覆写方法。覆写是面向对象编程技术的基础，并且是唯一没有被普遍劝阻的名字重用形式。

**隐藏（hide****）**

一个域、静态方法或成员类型可以分别隐藏（hide）在其超类中可访问到的具有相同名字（对方法而言就是相同的方法签名）的所有域、静态方法或成员类型。隐藏一个成员将阻止其被继承。

**重载（overload****）**

在某个类中的方法可以重载（overload）另一个方法，只要它们具有相同的名字和不同的签名。由调用所指定的重载方法是在编译期选定的。

**遮蔽（shadow****）**

一个变量、方法或类型可以分别遮蔽（shadow）在一个闭合的文本范围内的具有相同名字的所有变量、方法或类型。如果一个实体被遮蔽了，那么用它的简单名是无法引用到它的；根据实体的不同，有时根本就无法引用到它。

尽管遮蔽通常是被劝阻的，但是有一种通用的惯用法确实涉及遮蔽。构造器经常将来自其所在类的某个域名重用为一个参数，以传递这个命名域的值。这种惯用法并不是没有风险，但是大多数Java程序员都认为这种风格带来的实惠要超过其风险。

**遮掩（obscure****）**

一个变量可以遮掩具有相同名字的一个类型，只要它们都在同一个范围内：如果这个名字被用于变量与类型都被许可的范围，那么它将引用到变量上。相似地，一个变量或一个类型可以遮掩一个包。遮掩是唯一一种两个名字位于不同的名字空间的名字重用形式，这些名字空间包括：变量、包、方法或类型。如果一个类型或一个包被遮掩了，那么你不能通过其简单名引用到它，除非是在这样一个上下文环境中，即语法只允许在其名字空间中出现一种名字。遵守命名习惯就可以极大地消除产生遮掩的可能性。

# 8.        更多的库谜题

## 8.1    谜题76：乒乓

在一个同步化的静态方法执行之前，它会获取与它的Class对象相关联的一个管程（monitor）锁。

一个线程可以重复地获得某个相同的锁（可重入）。

对API设计者来说，如果一个线程没有一个公共的run方法，那么程序员就不可能意外地调用到它。Thread 类之所以有一个公共的run方法，是因为它实现了 Runnable 接口，但是这种方式并不是必须的。另外一种可选的设计方案是：使用组合（composition）来替代接口继承(interface inheritance)，让每个Thread实例都封装一个Runnable。组合通常比继承更可取。

## 8.2    谜题77：搞乱锁的妖怪

在内部，Thread.join方法在表示正在被连接（join）的那个Thread实例上调用Object.wait方法。这样就在等待期间释放了该对象上的锁。

除非有关于某个类的详细说明作为保证，否则千万不要假设库中的这个类对它的实例或类上的锁会做（或者不会做）某些事情。对于库的任何调用都可能会产生对wait、notify、notifyAll方法或者某个同步化方法的调用。所有这些，都可能对应用级的代码产生影响。

从5.0版本开始，java.util.concurrent.locks提供了2种可选方案：ReentrantLock和ReentrantReadWriteLock。相对于Object类，这2个类提供了更好的机动性，但是它们使用起来也要更麻烦一点。它们不能被用在同步化的语句块（synchronized block）中，而且必须辅以try-finally语句对其进行显式的获取和释放。

为了创建一个新的Thread实例，系统都会去获取Thread类上的锁。而执行下面的代码就可以阻止任何新线程的创建：

synchronized(Thread.class){ Thread.sleep(Long.MAX_VALUE); }

永远不要假设库类会（或者不会）对它的锁做某些事情。为了隔离你自己的程序与库类对锁的使用，除了那些专门设计用来被继承的库类之外，请避免继承其它库类。

对于语言设计者来说，需要考虑的是为每个对象都关联一个锁是否是合适的。如果决定这么做了，就需要考虑限制对这些锁的访问。在Java中，锁实际上是对象的公共属性，或许它们变为私有的会更有意义。同时请记住在Java语言中，

一个对象实际上就是一个锁：在对象本身之上进行同步。如果每个对象都有一个锁，而且可以通过调用一个访问器方法来获得它，这样或许会更有意义。

## 8.3    谜题78：反射的污染

访问位于其他包中的非公共类型的成员是不合法的。无论是一般的访问还是通过反射的访问，上述的禁律都是有效的。

应该只有在实例化时才使用反射，而方法调用都通过使用接口进行。

访问其他包中的非公共类型的成员是不合法的，即使这个成员同时也被声明为某个公共类型的公共成员也是如此。不论这个成员是否是通过反射被访问的，上述规则都是成立的。

## 8.4    谜题79：这是狗的生活

编译器会在包含有正确名称的方法的最内层范围内查找需要调用的方法。

受限的(qualified) this结构，Class.this.xxx。

## 8.5    谜题80：更深层的反射

关于Class.newInstance的文档叙述道：如果那个Class对象“代表了一个抽象类（abstract class），一个接口（interface），一个数组类（array class），一个原始类型（primitive type），或者是空（void）；或者这个类没有任何空的（也就是无参数的）构造器；或者实例化由于某些其他原因而失败，那么它就会抛出异常”。

一个非静态的嵌套类的构造器，在编译的时候会将一个隐藏的参数作为它的第一个参数，这个参数表示了它的直接外围实例（immediately enclosing instance）。当在代码中任何可以让编译器找到合适的外围实例的地方去调用构造器的时候，这个参数就会被隐式地传递进去。但是，上述的过程只适用于普通的构造器调用，也就是不使用反射的情况。当使用反射调用构造器时，这个隐藏的参数就需要被显式地传递，这对于Class.newInstance方法是不可能做到的。

除非确实是需要一个外围实例，否则应该优先使用静态成员类（static member class）而不是非静态成员类。

Java程序的反射模型和它的语言模型是不同的。反射操作处于虚拟机层次，暴露了很多从Java程序到class文件的翻译细节。这些细节当中的一部分由Java的语言规范来管理，但是其余的部分可能会随着不同的具体实现而有所不同。在Java语言的早期版本中，从Java程序到class文件的映射是很直接的，但是随着一些不能被虚拟机直接支持的高级语言特性的加入，如嵌套类（nested class）、协变返回类型（covariant return types）、泛型（generics）和枚举类型（enums），使得这种映射变得越来越复杂了。

考虑到从Java程序到class文件的映射的复杂度，请避免使用反射来实例化内部类。

## 8.6    谜题81：烧焦到无法识别

一个PrintStream可以被创建为自动刷新的；这意味着当一个字节数组(byte array)被写入，或者某个println方法被调用，或者一个换行字符或字节(‘\n’)被写入之后，PrintStream类型的flush方法就会被自动地调用。将指定的byte写入流。如果这个byte是一个换行字符，并且流可以自动刷新，那么flush方法将被调用，write(int)是唯一一个在自动刷新(automatic flushing)功能开启的情况下不刷新PrintStream的输出方法(output method)。如果用print(char)替代write(int)，它就会刷新System.out。这种行为与print(char)的文档是矛盾的，因为其文档叙述道：打印一个字符，这个字符将根据平台缺省的字符编码方式被翻译成为一个或多个字节，并且这些字节将完全按照write(int)方法的方式被写出。

## 8.7    谜题82：啤酒爆炸

由于某些本地平台只提供有限大小的缓冲，所以如果未能迅速地读取子进程(subprocess)的输出流，就有可能会导致子进程的阻塞，甚至是死锁。

为了确保子进程能够结束，必须排空它的输出流；对于错误流（error stream）也是一样，而且它可能会更麻烦，因为无法预测进程什么时候会倾倒（dump）一些输出到这个流中。在5.0版本中，加入了一个名为ProcessBuilder的类用于排空这些流。它的redirectErrorStream方法将各个流合并起来，所以只需要排空这一个流。如果决定不合并输出流和错误流，必须并行地（concurrently）排空它们。试图顺序化地（sequentially）排空它们会导致子进程被挂起。

## 8.8    谜题83：诵读困难者的一神论

可序列化的（serializable）类，在解序列（deserialization）时会创建一个隐藏的构造器。添加一个readResolve方法，它可以将那个隐藏的构造器转变为一个隐藏的静态工厂（static factory），以返回原来那个实例。

一个实现了Serializable的单件类，必须有一个readResolve方法，用以返回它的唯一的实例。

## 8.9    谜题84：被粗暴地中断

调用Thread.interrupted方法总是会清除当前线程的中断状态。方法的名称没有为这种行为提供任何线索，而对于5.0版本，在相应的文档中有一句话概要地也同样具有误导性地叙述道：“测试当前的线程是否中断”。所以，可以理解为什么很多程序员都没有意识到Thread.interrupted方法会对线程的中断状态造成影响。

Thread类有2个方法可以查询一个线程的中断状态。另外一个方法是一个名为isInterrupted的实例方法，而它不会清除线程的中断状态。

不要使用Thread.interrupted方法，除非想要清除当前线程的中断状态。如果只是想查询中断状态，请使用isInterrupted方法。

## 8.10              谜题85：惰性初始化

当一个线程访问一个类的某个成员的时候，它会去检查这个类是否已经被初始化。在忽略严重错误的情况下，有4种可能的情况：  

这个类尚未被初始化。

这个类正在被当前线程初始化：这是对初始化的递归请求。 

这个类正在被其他线程而不是当前线程初始化。 

这个类已经被初始化。

最好不要在类进行初始化的时候启动任何后台线程，要让类的初始化尽可能地简单。

在类的初始化期间等待某个后台线程很可能会造成死锁。要让类初始化的动作序列尽可能地简单。类的自动初始化被公认为是语言设计上的难题，Java的设计者们在这个方面做得很不错。如果写了一些复杂的类初始化代码，很多种情况下，这是在搬起石头砸自己的脚。

# 9.        高级谜题

## 9.1    谜题86：有毒的括号垃圾

插入一对看上去没有影响的括号可能会令合法的Java程序变得不合法。这种奇怪的情况是由于数值的二进制补码的不对称性引起的。

Java不支持负的十进制字面常量；int和long类型的负数常量都是由正数十进制字面常量前加一元负操作符（-）构成。在int类型的十进制字面常量中，最大的是2147483648。而从0到2147483647的所有十进制字面常量都可以在任何能够使用int类型字面常量的地方出现，但是字面常量2147483648只能作为一元负操作符的操作数来使用。

## 9.2    谜题87：紧张的关系

在数学中，等号（＝）定义了一种真实的数之间的等价关系（equivalence relation）。这种等价关系将一个集合分成许多等价类（equivalence class），每个等价类由所有相互相等的值组成。其他的等价关系包括有所有三角形集合上的“全等”关系和所有书的集合上的“有相同页数”的关系等。事实上，关系 ～ 是一种等价关系，当且仅当它是自反的、传递的和对称的。这些性质定义如下：  

自反性：对于所有x，x ～ x。也就是说，每个值与其自身存在关系 ～ 。

传递性：如果x ～ y 并且y ～ z，那么x ～ z。也就是说，如果第一个值与第二个值存在关系 ～，并且第二个值与第三个值存在关系 ～ ，那么第一个值与第三个值也存在关系 ～ 。

对称性：如果x ～ y，那么y ～ x。也就是说，如果第一个值和第二个值存在关系 ～ ，那么第二个值与第一个值也存在关系 ～。

操作符 == 不是自反的，因为表达式( Double.NaN == Double.NaN )值为false，表达式（ Float.NaN == Float.NaN ）也是如此。但并不违反对称性：对于所有x和y的值，（ x == y ）意味着（ y == x ）。

操作符 == 作用于原始类型的数值时不符合传递性。当比较两个原始类型数值时，操作符 == 首先进行二进制数据类型提升（binary numeric promotion）。这会导致这两个数值中有一个会进行拓宽原始类型转换（widening primitive conversion）。大部分拓宽原始类型转换是不会有问题的，但有三个值得注意的异常情况：将int或long值转换成float值，或long值转换成double值时，均会导致精度丢失。这种精度丢失可以证明 == 操作符的不可传递性。

要警惕到float和double类型的拓宽原始类型转换所造成的损失。它们是悄无声息的，但却是致命的。它们会违反直觉，并且可以造成非常微妙的错误。

## 9.3    谜题88：原生类型的处理

一个原生类型很像其对应的参数化类型，但是它的所有实例成员都要被替换掉，而替换物就是这些实例成员被擦除掉对应部分之后剩下的东西。具体地说，在一个实例方法声明中出现的每个参数化的类型都要被其对应的原生部分所取代。

原生类型List和参数化类型List<Object>是不一样的。如果使用了原生类型，编译器不会知道在list允许接受的元素类型上是否有任何限制，它会允许添加任何类型的元素到list中。这不是类型安全的：如果添加了一个错误类型的对象，那么在程序接下来的执行中的某个时刻，你会得到一个ClassCastException异常。如果使用了参数化类型List<Object>，编译器便会明白这个list可以包含任何类型的元素，所以你添加任何对象都是安全的。

List<?>是一种特殊的参数化类型，被称为通配符类型（wildcard type）。像原生类型List一样，编译器也不会知道它接受哪种类型的元素，但是因为List<?>是一个参数化类型，从语言上来说需要更强的类型检查。为了避免出现ClassCastException异常，编译器不允许添加除null以外的任何元素到一个类型为List<?>的list中。

原生类型是为兼容5.0版以前的已有代码而设计的，因为它们不能使用泛型。5.0版中的许多核心库类，如collections，已经利用泛型做了改变，但是使用这些类的已有程序的行为仍然与在以前的版本上运行一样。这些原生类型及其成员的行为被设计成可以镜像映射到5.0之前的Java语言上，从而保持了兼容性。

getAnnotation方法是泛型的。它是通过它的参数类型来确定返回类型的。具体地说，它接受一个Class<T>类型的参数，返回一个T类型的值；类名称字面常量提供了泛型信息。类名称字面常量可以传递运行时和编译时的类型信息。以这种方式使用的类名称字面常量被称作类型符号（type token）。

与类名称字面常量不同的是，通过反射获得的Class对象不能提供完整的泛型类型信息：Class.forName的返回类型是通配类型Class<?>。

原生类型的成员被擦掉，是为了模拟泛型被添加到语言中之前的那些类型的行为。如果你将原生类型和参数化类型混合使用，那么便无法获得使用泛型的所有好处，而且有可能产生令人困惑的编译错误。另外，原生类型和以Object为类型参数的参数化类型也不相同。

## 9.4    谜题89：泛型迷药

泛型类的内部类可以访问到其外围类的类型参数，这可能会使得程序模糊难懂。

在一个泛型类中设置一个内部类并不是必错的，但是很少用到这种情况，而且应该考虑重构代码来避免这种情况。当在一个泛型类中嵌套另一个泛型类时，最好为它们的类型参数设置不同的名字，即使那个嵌套类是静态的也应如此。对于语言设计者来说，或许应该考虑禁止类型参数的遮蔽机制，同样的，局部变量的遮蔽机制也应该被禁止。 

## 9.5    谜题90：荒谬痛苦的超类

要想实例化一个内部类，如类Inner1，需要提供一个外部类的实例给构造器。一般情况下，它是隐式地传递给构造器的，但是它也可以以expression.super(args)的方式通过超类构造器调用(superclass constructor invovation)显式地传递。如果外部类实例是隐式传递的，编译器会自动产生表达式：它使用this来指代最内部的其超类是一个成员变量的外部类。

一个类既是外部类又是其他类的超类的方式是很不合理的。扩展一个内部类的方式是很不恰当的；如果必须这样做的话，也要好好考虑其外部类实例的问题。另外，尽量用静态嵌套类而少用非静态的。

## 9.6    谜题91：序列杀手

HashSet的readObject方法在某些情况下，会间接地调用某个未初始化对象的被覆写的方法。为了组装(populate)正在被反序列化的散列集合，HashSet.readObject调用了HashMap.put方法，而它会去调用每个键(key)的hashCode方法。由于整个对象图（object graph）正在被反序列化，并没有什么可以保证每个键在它的hashCode方法被调用的时候已经被完全初始化了。

包含了HashMap的readObject方法的序列化系统总体上违背了不能从类的构造器或伪构造器（pseudoconstructor）中调用其可覆写方法的规则。

如果一个HashSet、Hashtable或HashMap被序列化，那么请确认它们的内容没有直接或间接地引用到它们自身。这里的内容（content），指的是元素、键和值。

Java的序列化系统是很脆弱的。为了正确而且高效地序列化大量的类，你必须编写readObject或readResolve方法。

## 9.7    谜题92：双绞线

所有的本地的、内部的、嵌套的和匿名的类都可以毫无限制地访问彼此的成员。

## 9.8    谜题93：类的战争

对于常量域的引用会在编译期被转化为它们所表示的常量的值。这样的域从技术上讲，被称作常量变量（constant variables），这可能在修辞上显得有点矛盾。一个常量变量的定义是：一个在编译期被常量表达式初始化的final的原始类型或String类型的变量。

编译期常量表达式(compile-time constant expression)

关键是null不是一个编译期常量表达式。

在5.0版本中引入的枚举常量（enum constants），虽然有这样一个名字，但是它们并不是常量变量。你可以在枚举类型中加入枚举常量，对它们重新排序，甚至可以移除没有用的枚举常量，而且并不需要重新编译客户端。

常量变量将会被编译进那些引用它们的类中。一个常量变量就是任何被常量表达式初始化的原始类型或字符串变量。令人惊讶的是，null不是一个常量表达式。

对于语言设计者来说，在一个动态链接的语言中，将常量表达式编译进客户端可能并不是一个好主意。

将常量表达式编译进客户端使得可以使用if语句来模拟条件编译（conditional compilation）

## 9.9    谜题94：迷失在混乱中

无

## 9.10              谜题95：只是些甜点

无