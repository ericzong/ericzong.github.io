---
layout: page
title: Effective Java 中文版（原书第 3 版）（阅读中……）
category: Java
tags: 持续更新
author: Eric Zong	
---

* content
{:toc}

# 推荐 序

关于语言必须掌握的三件事情：

1. 语法。语言的结构。
2. 词汇。命名。
3. 用法。以惯用和高效的方式来表达日常事物。

仅仅编写出能够有效地工作并且能够被别人理解的代码往往是不够的，我们还必须把代码组织成易于修改的形式。

# 第1章 引言

基本原则：

* 清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑。
* 组件[^1]要尽可能小，但又不能太小。
* 代码应该被重用，而不是被拷贝。
* 组件之间的依赖性应该尽可能地降到最小。
* 错误应该尽早被检测出来，最好是在编译时就发现并解决。

[^1]: 组件，任何可重用的软件元素，从单个方法，到包含多个包的复杂框架，都可以是一个组件。

代码：http://joshbloch.com/effectivejava

包级私有^*^（package-private，传统的描述性术语） <=> 包级访问（package access）

导出的 API（exported API）^*^，类、接口、构造器（constructor）、成员和序列化形式（serialized form）。

该 API 的用户（user），使用 API 编写程序的程序员。

该 API 的客户端（client），在类的实现中使用了 API 的类。

API 元素（API element），类、接口、构造器、成员以及序列化形式的统称。

# 第2章 创建和销毁对象

## 第1条：用静态工厂方法代替构造器

优势：

1. 它们有名称
2. 不必在每次调用它们的时候都创建一个新对象
3. 它们可以返回原返回类型的任何子类型的对象
4. 所返回的对象的类可以随着每次调用而发生变化，这取决于静态工厂方法的参数值
5. 方法返回的对象所属的类，在编写包含该静态工厂方法的类时可以不存在

缺点：

1. 类如果不含公有的或者受保护的构造器，就不能被子类化
2. 程序员很难发现它们

静态工厂惯用名称：

* from —— 类型转换方法，单个参数，返回该类型的一个相对应的实例
* of —— 聚合方法，带有多个参数，返回该类型的一个实例，把它们合并起来
* valueOf —— 比 from 和 of 更烦琐的一种替代方法
* instance / getInstance —— 返回的实例是通过方法的参数来描述的，但不能说与参数具有同样的值
* create / newInstance —— 像 instance 或 getInstance 一样，但 create 或者 newInstance 能够确保每次调用都返回一个新的实例
* get*Type*[^2] —— 像 getInstance 一样，但是在工厂方法处于不同的类中的时候使用
* *type* —— get*Type* 和 new*Type* 的简版

[^2]: *Type* 表示工厂方法所返回的对象类型。

## 第2条：遇到多个构造器参数时要考虑使用构建器

重叠构造器（telescoping constructor），提供的第一个构造器只有必要的参数，第二个构造器有一个可选参数，第三个构造器有两个可选参数，依此类推，最后一个构造器包含所有可选的参数。缺点：当有许多参数的时候，客户端代码会很难编写，较难阅读。

JavaBeans 模式，先调用一个无参构造器来创建对象，然后再调用 setter 方法来设置每个必要的参数，以及每个相关的可选参数。缺点：

1. 在构造过程中 JavaBean 可能处于不一致的状态；
2. 使得把类做成不可变的可能性不复存在。

Builder 模式模拟了具名的可选参数。

如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder 模式是一种不错的选择。

Builder 模式的客户端代码比重叠构造器模式更易于阅读和编写，比 JavaBean 更加安全。

## 第3条：用私有构造器或者枚举类型强化 Singleton 属性

Singleton 通常代表一个无状态对象，或本质上唯一的系统组件。

Singleton 类使客户端测试变得十分困难，因为不可能给它替换模拟实现，除非实现一个充当其类型的接口。

公有域方法，优势：

1. API 清楚表明其是一个 Singleton 类；
2. 更简单。

静态工厂方法，优势（除非有以下优势，否则优先使用公有域方法）：

1. 提供了灵活性（不改变 API 的前提下，可修改为非 Singleton）；

2. 可以编写一个泛型 Singleton 工厂（generic singleton factory）；
3. 可以通过方法引用（method reference）作为提供者。

单元素枚举类型常是实现 Singleton 的最佳方法。缺点：Singleton 必须扩展一个超类，而不扩展 `Enum` 时不可用。

## 第4条：通过私有构造器强化不可实例化的能力

## 第5条：优先考虑依赖注入来引用资源

静态工具类和 Singleton 类不适合于需要引用底层资源的类。

依赖注入缺点：导致大型项目凌乱不堪，因此它通常包含上千个依赖。需要使用依赖注入框架。

依赖注入优点：极大提升类灵活性、可重用性和可测试性。

## 第6条：避免创建不必要的对象

如果对象是不可变的（immutable），就始终可被重用。

静态工厂方法和构造器同时提供时，优先使用静态工厂方法。

自动装箱使得基本类型和装箱基本类型之间的差别变得模糊，但没有完全消除。

要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。

必要时如果没能实施保护性拷贝，将会导致潜在的 Bug 和安全漏洞；而不必要地创建对象则只会影响程序的风格和性能。

## 第7条：消除过期的对象引用

清空对象引用应该是一种例外，而不是一种规范行为。

消除过期引用最好的方法是让包含该引用的变量结束其生命周期。

内存泄漏的常见来源：

1. 类是自己管理内存
2. 缓存
3. 监听器和其他回调