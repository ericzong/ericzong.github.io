---
layout: page
title: Thinking in Java
category: Java
author: "Eric Zong"
---

* content
{:toc}

# 第1章 对象导论

子父类产生差异的方法：1.子类添加新方法；2.覆盖/重写

# 第2章 一切都是对象

方法签名=方法名+参数列表（唯一标识方法）

调用方法的行为→发送消息给对象 [^1]

# 第3章 操作符

一元加号唯一的作用：将较小类型的操作数提升为int。

按位操作直接操纵硬件，设置硬件寄存器内的二进制位。

由于位非常“小”，按位操作符仅使用一个字符。(^_^)

布尔类型，单比特值。不能按位“非”，位、逻辑效果相同，位不“短路”。

移位，只处理整数类型。1.左移<< 0；2.右移>>(+)0/(-)1；3.>>>0(无符号扩展) [^2]

窄化转换扩展转换

# 第4章 控制执行流程

逗号分隔符：1.只用于for循环控制表达式：初始化、步进；2.定义多个变量，但类型须相同。

需要标签的唯一理由：有循环嵌套存在。

# 第5章 初始化与清理

new表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值。

构造器是强制重载方法的一个原因。

如果实参类型小于形参类型，实参类型将会被提升。char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

如果实参类型大于形参类型，将会进行窄化转换。

可以用this调用一个构造器，但不能调用两个。必须将构造器调用置于最起始处，否则编译器会报错。

无法阻止自动初始化的进行，它将在构造器被调用之前发生。

即使变量定义散布于方法定义之间，它们仍旧会在任何方法（包括构造器）被调用之前得到初始化。

对象创建过程，假设有个名为Dog的类：

1.即使没有显式地使用static关键字，构造器实际上也是静态方法。因此，当首次创建类型为Dog的对象时（构造器可以看成静态方法），或者Dog类静态方法/静态域首次被访问时，Java解释器必须查找类路径，以定位Dog.class文件。

2.然后载入Dog.class（创建一个Class对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在Class对象首次加载的时候进行一次。[^3]

3.当用new Dog()创建对象的时候，首先将在堆上为Dog对象分配足够的存储空间。

4.这块存储空间会被清零，这就自动地将Dog对象中的所有基本类型数据都设置成了默认值，而引用则被设置成为null。[^4]

5.执行所有出现于字段定义处的初始化动作。

6.执行构造器。这可能会牵涉到很多动作，尤其是涉及继承的时候。[^5]

类静态变量初始化：1.创建类对象；2.类.变量 [^6]

数组｛｝初始化方式必须在创建数组的地方出现，例如：int[] a1 = {1, 2, 3, 4, 5};

数组初始化列表的最后一个逗号都是可选的，这一特性使维护长列表变得更容易。

# 第6章 访问权限控制

package语句必须是除注释外第一句程序代码。

默认构造器若是唯一定义的构造器，且为private，则将阻碍对此类的继承。

非同包类子类不能访问父类的包访问权限的方法。

访问权限控制 = 具体实现的隐藏

数据、方法包装进类 + 具体实现的隐藏 = 封装[^7]

为了控制某个类的访问权限，修饰词必须出现于关键字class之前。

一个内部类可以是private或是protected的。[^8]

相同目录下的所有不具有明确package声明的文件，都被视作是该目录下默认包的一部分。

# 第7章 复用类

惰性初始化：在正要使用对象之前初始化。

当创建一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与用基类创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。

组合和继承都允许在新的类中放置子对象，组合的是显式地这样做，而继承则是隐式地做。

编译期常量，编译器可以将该值代入任何可以用到它的计算式中，并在编译时执行计算式。要求：1.基本数据类型；2.final；3.定义赋值。一个既是static又是final的域只占据一段不能改变的存储空间，称为“恒定初始值”。final引用恒定不变，所引用的对象可修改的。

空白final：被声明为final但又未给定初值的域。编译器确保空白final在使用前必须被初始化。空白final可以让一个类中的final域做到根据对象而有所不同，却又保持其恒定不变的特性。

使用final方法原因：1.方法锁定，以防任何继承类修改其含义；2.效率，同意编译器将针对该方法的所有调用都转为内嵌调用。

类中所有的private方法都隐式地指定为final的。

“覆盖”只有在某方法是基类接口的一部分时才会出现，如果某方法为private，它就不是基类接口的一部分。

由于final类禁止继承，所以final类中所有的方法都隐式指定为final的，因为无法覆盖它们。

类是在其任何static成员被访问时加载的。

对象成员变量预初始化是通过将对象内存设为二进制0而一举生成的。

# 第8章 多态

多态作用：消除类型之间的耦合关系。

多态 = 动态绑定、后期绑定、运行时绑定

上转型可能会“缩小”接口，但不会比父类全部接口更窄。

绑定：将一个方法调用同一个方法主体关联起来。

前期绑定：在程序执行前进行绑定。

后期绑定：在运行时根据对象的类型进行绑定。

Java中除了static方法和final方法（private方法在内）之外，其他所有的方法都是后期绑定。

当子对象转型为父类对象引用时，任何域访问操作都将由编译器解析，不是多态的。

调用构造器顺序：1.调用基类构造器；2.按声明顺序调用成员的初始化方法；3.调用导出类构造器的主体。

在构造器内唯一能够安全调用的方法是基类中的final方法。[^9]

协变返回类型：在导出类中的被覆盖方法可以返回基类方法的返回类型的某种导出类型。[^10]

用继承表达行为间的差异，并用字段表达状态上的变化。

# 第9章 接口

可在interface前加public，但仅限该接口在其同名文件中被定义。[^11]

接口是根本没有任何具体实现的，没有任何与接口相关的存储，也就无法阻止多个接口的组合。

将一个具体类和多个接口组合到一起时，具体类必须放在前面，后面跟着的才是接口。

使用接口的核心原因：1.为了能够向上转型为多个基类型；[^12] 2.防止客户端程序员创建该类的对象，并确保这仅仅是建立一个接口。

在接口中定义的域不能是“空final”，但可以被非常量表达式初始化。

嵌套的内部接口可以被实现为private的，也适用于嵌套类。实现一个private接口只是一种方式，它可以强制该接口中的方法定义不要添加任何类型信息，即不允许向上转型。

一个返回对private接口的引用的public方法，只能将返回值交给有权使用它的对象。

嵌套在一个接口中的接口自动就是public 的，而不能声明为private的。[^13]

当实现某个接口时，并不需要实现嵌套在其内部的任何接口。而且，private接口不能在定义它的类之外被实现。

# 第10章 内部类

内部类拥有其外围类的所有元素的访问权。

当某个外围类对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外围类对象的引用。

内部类的对象只能在与其外围类的对象相关联的情况下才能被创建。构建内部类对象时，需要一个指向其外围类对象的引用，如果编译器访问不到这个引用就会报错。

创建某个内部类对象，必须在new表达式中提供对其他外部类对象的引用，需要使用.new语法，例：DotNew.Inner dni = dn.new Inner();

在拥有外部类对象之前是不可能创建内部类对象的。因为内部类对象会暗暗地连接到创建它的外部类对象上。创建的是嵌套类（静态内部类），那就不需要对外部类对象的引用。

匿名内部类末尾的分号，不是用来标记此内部类结束的。标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。

如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的。但如果参数是基本数据类型则不必是final的，因为参数被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。

对于匿名类而言，实例初始化的实际效果就是构造器。不能重载实例初始化方法，所以仅有一个这样的构造器。

匿名内部类与正规的继承相比有些受限，因为匿名内部类可以扩展类，也可以实现接口，但是不能两者兼备。如果是实现接口，也只能实现一个接口。

嵌套类特性：1.要创建嵌套类的对象，并不需要其外围类的对象。2.不能从嵌套类的对象中访问非静态的外围类对象。

嵌套类/普通内部类：普通内部类不能有static数据和static 字段，也不能包含嵌套类。但嵌套类可以包含所有这些东西。

可以在内部类中实现其外围接口。

需要内部类的原因：每个内部类都能独立地继承自一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响。

闭包：一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。

内部类是面向对象的闭包。

当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化。

局部内部类不能有访问说明符，因为它不是外围类的一部分[^14]，但可以访问当前代码块内的常量，以及此外围类的所有成员。

局部内部类/匿名类：前者可以有构造器，后者没有构造器。

局部内部类名字在方法外不可见，使用它的唯一理由是：需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实例初始化。

# 第11章 持有对象

队列规则：在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是是等待时间最长的元素。优先级队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。

C++中容器之间所有共性都是通过迭代器达成的。Java也用迭代器而不是Collection来表示容器之间的共性。但两者绑定到了一起，因为实现Collection就意味着需要提供iterator()方法。

# 第12章 通过异常处理错误

如果只是把当前异常对象重新抛出，那么printStackTrace()方法显示的将是原来异常抛出点的调用栈信息，而并非重新抛出点的信息。要想更新这个信息，可以调用fillInStackTree()方法。

如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。

# 第14章 类型信息

在查询类型信息时，以instanceof的形式（即以instanceof的形式或isInstance()的形式，它们产生相同的结果）与直接比较Class对象有一个很重要的差别。前者判别类或派生类，后者只类别这个类。

RTTI和反射之间真正的区别只在于对RTTI来说，编辑器在编译时打开和检查.class文件。对于反射机制来说，.class文件在编译时是不可获取的，所以是在运行时打开和检查.class文件。

# 第15章 泛型

return语句只允许返回单个对象，如果仅一次方法调用返回多个对象，就要创建一个对象，用它来持有想要返回的多个对象。

元组：将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。这也称为“数据传送对象”或“信使”。

如果使用泛型方法可以取代将整个类泛型化，那么就应该只使用泛型方法，因为它可以使事情更清楚。对于一个static的方法而言，无法访问泛型类的类型参数，如果static方法需要使用泛型能力，就必须使其成为泛型方法。

当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。这称为“类型参数推断”。

类型推断只对赋值操作有效，其他时候并不起作用。

要显式地指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内。如果是在定义该方法的类的内部，必须在点操作符之前使用this关键字，如果是使用static的方法，必须在点操作符之前加上类名。

---

[^1]: 当“变量.方法”时，变量指向的对象被使用

[^2]: Int及long类型上定义了移位操作符，对于byte/short/char，将提升至int

[^3]: 准确地说，至少在类成员被访问之前进行，因为Class.forName()可以只加载类而不初始化。

[^4]: 自动初始化<=>内存清0

[^5]: 上溯执行祖先类构造器
[^6]: 即类成员被访问时
[^7]: 体现整体性、封闭性
[^8]: 内部类外层程序单元是外部类
[^9]: 否则子类可能会重写该方法，从而导致子类的域在初始化之前被访问
[^10]: 符合“包容性原则”
[^11]: 新版本中可添加默认实现
[^12]: 接口回调
[^13]: 强制默认
[^14]: 外层程序单元是方法

